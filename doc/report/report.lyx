#LyX 1.6.8 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Resurrecting the TEP Mini-Mill
\end_layout

\begin_layout Author
Charlie Blake
\begin_inset Newline newline
\end_inset

Philippa Chilvers Woolley
\begin_inset Newline newline
\end_inset

Abigail Cox
\begin_inset Newline newline
\end_inset

Melisa Kaner
\end_layout

\begin_layout Abstract
<insert summary here>
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Abstract - Charlie - 1
\end_layout

\begin_layout Section
Problem - Mel - 1
\end_layout

\begin_layout Standard
At Bancroft's School, there is an old and now unfortunatly, disused CNC
 drill used to drill holes in PCB circuit boards.
 The control box that is used to both manually and automatically control
 the CNC drill requests a 'smart card' for operation, which we dont have.
 Currently, all od the drill holes from printed circuit boards have to be
 drilled by hand, this is both arduous and inefficient when compared to
 the previously automated drill.
 The aim is to replace this control box completely of its functions and
 perhaps refine some of the finer points in the program.
 A more long term aim is to physically replace the control box, giving it
 more of a user interface.
 The newly created control box would also include manual control.
\end_layout

\begin_layout Section
Research
\end_layout

\begin_layout Subsection
Original Equipment Manufacture - Abi - 1 
\end_layout

\begin_layout Standard
At Cambridge, the team realised that in order to get any sensible use out
 of the machine, it would be practical to be able to operate it via laptops.
 Since the machine didn’t have a smart card, it was necessary to find any
 existing documentation on the product to begin to work out how to control
 it remotely.
 Possible manufactures and suppliers of the product were researched online.
 The few leads which came up were Middlesex University and Mindsets.
 After a few phone calls, it was discovered that since the machine was made
 decades ago, it was now considered obsolete.
 As this was the case, there were not any user manuals or instructions for
 the machine except by post.
 Mindsets offered to send some documentation to us, but this would have
 taken a few weeks.
\end_layout

\begin_layout Subsection
Reverse Engineering the Circuit Board - Pippa - 4
\end_layout

\begin_layout Standard

\series bold
Did we still ask them to send documents to school? What did we do instead?
\end_layout

\begin_layout Subsection
Opening up the CNC Drill 
\end_layout

\begin_layout Standard
Upon opening up the CNC drill it was found that, as suspected, it was controlled
 using a uni-polar stepper motor.
 These are different from conventional motors because of the following:
\end_layout

\begin_layout Itemize
Brushless – (if brushed, with friction could create sparks which especially
 in our case is undesirable)
\end_layout

\begin_layout Itemize
Good low speed and holding torque – ( can hold particular positions in rotation
 even without a power input)
\end_layout

\begin_layout Itemize
Open loop positioning – ( Can position the shaft in precise, predictable
 positions )
\end_layout

\begin_layout Itemize
Load independent ( The rotation speed of the motor is free of the load)
\end_layout

\begin_layout Subsection
Motor Control Circuitry
\end_layout

\begin_layout Standard
Current flowing though a coil produces a magnetic field, this in turn, attracts
 a ‘permenanent magnet rotor’ which is connected to the shaft of the motor
 as shown in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stepper-motor"

\end_inset

.
 By reversing the current through two coils of the stepper motor in a particular
 sequence, the rotor is influenced.
 There are two coils and two directions, giving us a 
\begin_inset Quotes eld
\end_inset

4-phase sequence
\begin_inset Quotes erd
\end_inset

.
 By getting this sequence right, we can make the motor turn smoothly.
 This 
\begin_inset Quotes eld
\end_inset

4-phase sequence
\begin_inset Quotes erd
\end_inset

 is repeated many times before a complete revolution.
 This is created using 4 electromagnets equidistant from one another and
 once each electromagnet is turned on in turn rotating the shaft by 1.8°.
 This allows the motor to turn in 
\series bold
steps, 
\series default
more specifically there are 200 steps in one rotation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename stepper_motor.png
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Conceptual diagram of a stepper motor
\begin_inset CommandInset label
LatexCommand label
name "fig:stepper-motor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Manual Control - Switches - Mel - 3
\end_layout

\begin_layout Standard
By using a stepper motor ordered from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.rapidonline.com
\end_layout

\end_inset

, it was possible to experiment finding the correct wiring sequence without
 the threat of harming the motor inside of the drill.
 By connecting each of the inputs to a series of switches in a spare prototype
 board it was possible to turn on each of the 
\begin_inset Quotes eld
\end_inset

bits
\begin_inset Quotes erd
\end_inset

 in order to find the correct sequence.
 
\end_layout

\begin_layout Standard
The switches were arranged in such a way that a logic '1' was created when
 the switch was pressed, this corresponds to the logic levels used later
 on.
\end_layout

\begin_layout Standard
In order to find the correct sequence, created a diagram of the stepper
 motor inputs 
\series bold
[insert diagram]
\series default
 and logically work out each of the sequences.
 As mentioned earlier, if a current is passed through one of the stepper
 motor inputs the polarity of the magnet changes.
 As the stepper motor being used is a unipole stepper motor if any two adjacent
 poles are 'on' at the same time, the polarity between the two magnets essential
ly cancel out.
 This shouldn't move/rotate the shaft of the motor.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../elec/XYcontroller.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Switch with Stepper motor
\begin_inset CommandInset label
LatexCommand label
name "fig:Switch-with-Stepper"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
After experimenting with different sequences, the following sequences that
 were found worked best:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ROTATION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LEFT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0110
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1001
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RIGHT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0110
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1001
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This method, however, proved to be very limited as it was not possible to
 see the speed and torque limitations of the motor.
 
\end_layout

\begin_layout Subsection
Using the 4017 Decade Counter - Mel - 2
\end_layout

\begin_layout Standard
It was then interesting to find how the motor would run if we increased
 the speed of these incoming bits, as the switches could only be pressed
 in sequence at a limited speed.
 To do this we used a 
\begin_inset Quotes eld
\end_inset

555 Astable
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

4017 Decade Counter
\begin_inset Quotes erd
\end_inset

, as shown in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stepper-4017"

\end_inset

.
 
\end_layout

\begin_layout Standard
To find the correct wiring configuration, we created a table in an attempt
 to find the correct sequence of inputs.
\end_layout

\begin_layout Standard
A B C D 
\end_layout

\begin_layout Standard
1 0 1 0 
\end_layout

\begin_layout Standard
1 0 0 1
\end_layout

\begin_layout Standard
0 1 0 1
\end_layout

\begin_layout Standard
0 1 1 0
\end_layout

\begin_layout Standard
Arranging the inputs so that (as found earlier) each of the inputs have
 to be adjacent:
\end_layout

\begin_layout Standard
C A D B
\end_layout

\begin_layout Standard
1 1 0 0
\end_layout

\begin_layout Standard
0 1 1 0
\end_layout

\begin_layout Standard
0 0 1 1 
\end_layout

\begin_layout Standard
1 0 0 1
\end_layout

\begin_layout Standard
Using the decade counter (which cycles sequentially through its inputs )
 We could create the inputs of
\end_layout

\begin_layout Standard
C A D B
\end_layout

\begin_layout Standard
1 0 0 0
\end_layout

\begin_layout Standard
0 1 0 0
\end_layout

\begin_layout Standard
0 0 1 0
\end_layout

\begin_layout Standard
0 0 0 1
\end_layout

\begin_layout Standard
This would still rotate the shaft of the stepper motor smoothly, but not
 have as much torque.
 The origionally desired logic could be obtained using an arrangment of
 diodes at the 4017 outputs, but for testing and time purposes, the current
 arrangment served its purpose (As an increased torque wasn't needed in
 this situation).
 
\end_layout

\begin_layout Standard
To a suitable frequency for the 555 astable, it was taken into account that
 the stepper motor would have to rotate in 200 steps, a frequency of around
 100Hz (pulsing at 100 times per second) would allow the stepper motor to
 rotate fully in 2 seconds.
 This speed was unlikely tp surpass the limits of the stepper motor.
 After connecting this to the decade counter, a Darlington Driver was required
 in order to drive the stepper motor without burning out the 4017 decade
 counter.
 To increase the rotation speed, it was merely needed to change the components
 of the frequency generator (555 Astable), more specifically, the capacitor
 and resistor values.
 Using the E12 series of resistors, a frequency of around 120Hz was created,
 which is a close enough experimental value to serve its purpose.Values were
 calculated for the needed resistors and capacitors using 1.44/(R1 + 2R2)C.
 The final values used were 1 micro farad, R1 = 10K Ohms, R2 = 1K Ohms.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../elec/stepper_4017.eps
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Simple stepper motor driver
\begin_inset CommandInset label
LatexCommand label
name "fig:stepper-4017"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This worked as expected and it was now possible to proceed onto a more automated
 method of controlling the stepper motor.
\end_layout

\begin_layout Subsection
Using a Laptop - Mel - 2
\end_layout

\begin_layout Standard
The rotation speed of the motor depended on the value of the capacitor in
 the astable, wanting to experiment further the values of the capacitor
 were increased to such a degree that there was too much torque and the
 motor wouldn’t turn.
 It was here that the limits of the motor were found.
 After confirmation that this method worked, the next step was to utilise
 this with laptops.
 A simple program was devised to scroll through the outputs in a specified
 sequence.
 [refer to appendix?] As with using the laptops, the frequency generated
 would greatly surpass the limit of 200Hz, to recitfy this the program had
 to intergrate 'sleep' commands.
 This made it possible to easily to vary the speed of rotation as well as
 the direction.
 
\end_layout

\begin_layout Standard
The next step was to use this idea with the CNC drill, beginning with controllin
g individual axes.
 The programming lines of the laptops were connected as were the components
 to the inputs of the drill (previously where the control box had been situated)
, a simple program was created to cycle through outputs representing the
 4017 outputs and noted in which direction each of the axes moved.
 We then wanted to be able to have the drill move to a specific co-ordinate,
 we did this by creating variables 
\begin_inset Quotes eld
\end_inset

x_target
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

y_target
\begin_inset Quotes erd
\end_inset

 which would be variables that the 'user' types in themselves, in the command
 prompt.
 This would be constantly corresponding to the variables 
\begin_inset Quotes eld
\end_inset

x_position
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

y_position
\begin_inset Quotes erd
\end_inset

 which fittingly correspond to the current positions of the drill, in the
 x and y position.
 The drill stops moving once x_target is equal to x_position (the same for
 the y co-ordinates), if the x and y postions are less than the targets,
 then the x and y variables increment by one every clocked pulse coming
 from the IC.
 
\end_layout

\begin_layout Standard
Error messages were also implemented in the event of unrecognized co-ordinates
 coming from the interface.
 This ensures that the program doesn't go into an unexpected error state
 during movement or even if the drill is moving to unspecified co-ordinates
 which would prove more troublesome in the future.
 
\end_layout

\begin_layout Standard
Reflecting that the long term aim of the project was to interpret drill
 files, the next milestone would be to directly extrapolate the X and Y
 co-ordinates from the drill files and use them as x_target and y_target
 respectively.
\end_layout

\begin_layout Standard

\series bold
[insert from code??]
\end_layout

\begin_layout Subsection
Proof of Concept - Charlie - 2
\end_layout

\begin_layout Standard
Once a program able to drive an independant stepper motor had been created,
 the next task was to connect it to the stepper motors within the Mini Mill.
 Having already reverse-engineered the circuitry within the machine itself,
 it was possible to identify the four inputs to each of the stepper motors
 and connect them to a breadboard via the rs232 cable.
 The dlpusb245 was then connected to the same breadboard, allowing the motors
 to be controlled from a laptop.
 The existing program was then able to drive the drill in the X and Y directions
 both forward and backwards.
\end_layout

\begin_layout Standard
A separate program then needed to be created in order to move the drill
 to a specific co-ordinate.
 For the previous program a sequence of 1000 steps moved the drill 1cm.
 As the movement distance in the X direction is 28cm and the movement distance
 in the Y direction is 18cm, the maximum drill co-ordinates, in terms of
 steps, is ( 28000, 18000 ).
 The drill has no way of sending its current set of co-ordinates to the
 laptop, so a system of callibrating the drill was needed.
 The only drill locations where the spatial co-ordinates can be accurately
 predicted are the four corners, so when we created our new program we made
 sure that as soon as it begins the drill is set to run into the top-right
 hand corner.
 To do this the motors are initially given the instruction to move 30,000
 steps in the X axis and 20,000 steps in the Y axis.
 This runs the drill into the bottom corner regardless of its initial position,
 as it is attempting to move the total distance of the whole movement plane.
\end_layout

\begin_layout LyX-Code
/* The function move-to-targets is called with the co-ordinates 30,000 and
 20,000
\end_layout

\begin_layout LyX-Code
being sent.
 This runs the drill into the top-right hand corner */
\end_layout

\begin_layout LyX-Code
lusbrc = move_to_target ( &device, 30000, 20000, 0, 0 )
\end_layout

\begin_layout Standard
When x and y co-ordinates are sent to our program they are stored in two
 variables named 
\begin_inset Quotes eld
\end_inset

target_x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

target_y
\begin_inset Quotes erd
\end_inset

.
 As these inputed co-ordinates are in centimeters, they are multiplied by
 1000 before being stored as this will give the distance in terms of the
 number of steps.
\end_layout

\begin_layout LyX-Code
/* Define the used variables */
\end_layout

\begin_layout LyX-Code
unsigned int a_target_x;
\end_layout

\begin_layout LyX-Code
unsigned int a_target_y;
\end_layout

\begin_layout LyX-Code
unsigned int target_x;
\end_layout

\begin_layout LyX-Code
unsigned int target_y;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* This loop takes the inputted co-ordinates, multiplies by 1000 and stores
 them */
\end_layout

\begin_layout LyX-Code
while ( 1 )
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
scanf ( "%d,%d", &a_target_x, &a_target_y );
\end_layout

\begin_layout LyX-Code
target_x = a_target_x*1000
\end_layout

\begin_layout LyX-Code
target_y = a_target_y*1000;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The program also holds two other variables named simply 'x' and 'y'.
 These variables are supposed to represent the current position of the drill
 and so they begin at ( 0, 0 ).
 When 
\begin_inset Quotes eld
\end_inset

target_x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

target_y
\begin_inset Quotes erd
\end_inset

 recieve values, the program checks to see if 'x' and 'y' are less than,
 equal to or greater than them.
 If they are less (as they will be initially) then the stepper motors are
 instructed to drive through their sequence forwards.
 Every time the x or y motor advances a step, the corresponding 'x' or 'y'
 variable is incremented until it equals its target value.
 When both 'x' and 'y' equal their target values the drill will be in the
 correct position and the program is ready to recieve a new co-ordinate.
 If this co-ordinate is then less than 'x' and 'y', the stepper sequence
 will run backwards and the position variables will decrement every step.
 
\end_layout

\begin_layout LyX-Code
/* Define the new variables */
\end_layout

\begin_layout LyX-Code
unsigned int x;
\end_layout

\begin_layout LyX-Code
unsigned int y;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* This loop operates while the position co-ordinated do not equal the destinati
on
\end_layout

\begin_layout LyX-Code
co-ordinates */
\end_layout

\begin_layout LyX-Code
while ( ( x != target_x ) || ( y != target_y ) )
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* full_step_x and full_step_y are external functions defined elswhere.
 This line
\end_layout

\begin_layout LyX-Code
increases the stepper motor sequence by one stage for every increase in
 x or y */
\end_layout

\begin_layout LyX-Code
bits = ( full_step_y.bits [ y % 4 ] | full_step_x.bits [ x % 4 ] );
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* Sends the current stage in the stepper sequence to dlpusb245 */
\end_layout

\begin_layout LyX-Code
if ( ( lusbrc = set_output_value ( device, bits ) ) < 0 ) return lusbrc;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* The program pauses for one millisecond as the motors have a maximum sequence
\end_layout

\begin_layout LyX-Code
cycle speed */
\end_layout

\begin_layout LyX-Code
usleep ( 1000 ); 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* The program increases x and y if they are smaller than their targets,
 and
\end_layout

\begin_layout LyX-Code
decreases them if they are larger */
\end_layout

\begin_layout LyX-Code
if ( x < target_x ) { x++; }
\end_layout

\begin_layout LyX-Code
else if ( x > target_x ) { x--; } 
\end_layout

\begin_layout LyX-Code
if ( y < target_y ) { y++; }
\end_layout

\begin_layout LyX-Code
else if ( y > target_y ) { y--; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
A set of co-ordinates was then created to outline a simple image.
 A panda outline was chosen as our test design.
 This shape could not be milled as the program had no control over the drill
 up/down function and the correct milling cutters were not avaliable at
 the time.
 Instead a pencil was taped to the side of the drill and a sheet of paper
 was placed on the drilling surface so that movement would result in an
 image being drawn.
 The individual co-ordinates were then sent to our program and the machine
 drew the required shape.
 The resulting image was faint and slightly wobbly, but the outline of the
 Panda that our co-ordinates specified was still clearly visible, as seen
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Panda_image"

\end_inset

.
 This successful demonstration marked the end the Cambridge Workshop for
 the team.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Panda.jpg
	width 13cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Panda image drawn by the Mini Mill
\begin_inset CommandInset label
LatexCommand label
name "fig:Panda_image"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
See the appendix for the code in full.
 The program is named 
\begin_inset Quotes eld
\end_inset

dlpusb245_control.c
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Solution
\end_layout

\begin_layout Subsection
Manual Control & RS232 PCBs - Abi - 1
\end_layout

\begin_layout Subsection
Flowcharts & Event-based Programming - Abi - 3
\end_layout

\begin_layout Subsection
CNC Control - Mel - 5/6
\end_layout

\begin_layout Standard
After the success of controlling the CNC with co-ordinates typed in by the
 user, the next step would be interepreting individual co-ordinates from
 drill files.
 The next step was to make the target x and y variables update automatically
 according to a list.
 For example, a block of text containing x and y co-ordinates would be translate
d into x_target and y_target co-ordinates.
 These were called the producer and consumer, the program starts off with
 a number of co-ordinates in the producer (these are the co-ordinates typed
 in) and once these are processed, or 
\series bold
consumed, 
\series default
these become the consumer - finished co-ordinates.
 But, if there were any unrecognized characters (ones that dont translate
 into co-ordinates), there needed to be a way to make sure the program wouldn't
 register them as co-ordinates and go into a random error state.
 It was here we further utilised error states in using colour coded LEDs,
 Red meaning error, Orange meaning processing and Green meaning idle.
 
\end_layout

\begin_layout Standard
After the new x and y targets were found, the program needed to recognize
 where those co-ordinates were in relative to its position.
 To do this, a 'sign function' was created which uses the principle that
 If the x_target - x_position was positive (I.e the x_position relative to
 the x_target was positive), then it needed to carry on moving to the right
 (right is positive in this case), if it was negative then it needed to
 move left and if it was 0, then the x_position had reached x_target and
 that axis could stop moving.
 This would result in a square motion of the drill.
 To make the stepper rotate accordingly (clockwise or anticlockwise), the
 'mod' function was used, this told the stepper motor what orientation the
 shaft should be.
 For example, we had a storage device within the program containing 4 outputs,
 recognizable as [1100 0110 0011 1001] by using the mod function on x_position
 and y_position, the stepper motor would know whether to rotate positively
 (clockwise) or negatively (anticlockwise).
 The stepper motor position variables were called xstepperpos and ystepperpos
 respecitvely.
\end_layout

\begin_layout Standard
For a safety feature (as well as practicality), if the dril had not reached
 its position, (i.e.
 x_target isn't equal to x_position and y_target isn't equal to y_position)
 the drill would always be up.
 Only once the drill is in it's desired position would the drill go down
 and drill the hole.
 To make sure the motion wasn't too fast (otherwise this could break the
 drill bit but also dril a non-uniform hole) a timer was implemented into
 the system (Being to made to last a couple of seconds, which was acceptable).
 
\end_layout

\begin_layout Standard
When the counter equalled 0, if there were no more co-ordinates to drill
 (I.e.
 the number of co-ordinates in the producer is equal to the consumer - all
 the produced co-ordinates had been 'consumed'), the activity led is set
 low (to signify that the program has finsihed) and the program ends.
 If the producer doesnt equal the consumer, then one is added to the consumer
 (as the program as drilled one co-ordinate, so it needs to be consumed)
 and the next producer becomes the new target.
 (We again split up the producer and consumer into it's x and y constituents.)
\end_layout

\begin_layout Standard
But, as the x and y target variables have a limited capacity, if there were
 any new co-ordinates coming into the variable when it is still processing
 current ones (ie more co-ordinates than can be stored), they would be overwritt
en.
 To prevent this, flow control needed to be implemented.
\end_layout

\begin_layout Subsubsection
Flow Control
\end_layout

\begin_layout Standard
Flow controll is essentially a buffer that is created between (in this case)
 the computer and the PCB (circuit) that halts the flow of data untill it
 can be taken in/there is a space for it to be processed.
\end_layout

\begin_layout Standard
Though, after referring to our circuit diagram 
\series bold
[refer to circuit diagram here]
\series default
 it was found that there physically wasn't any space on our current circuit
 board for the flow control lines to be implemented.
 It was then that we went back to eeschema (circuit diagram software) to
 find any free data lines.
 The lines we had to change were RTS and CTS, R - Recieve, T - Transmitt.When
 RTS is high (1), this is telling the computer that it is ready to recieve
 data, low meaning it has to be halted.
 In order to understand fully what output lines we could untilise, we created
 the following table:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COMPUTER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TO/FROM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CIRCUIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MICROCONTROLLER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TXD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FROM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RXD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
----
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FROM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MISO
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Standard
As we aren't actually recieving any data from the circuit (we are feeding
 it co-ordinates), we really only needed one free data line, here we used
 MISO, only 3 connections on the current PCB.
 
\series bold
[summarise with flowcharts and modified circuit diagram?] 
\end_layout

\begin_layout Subsection
Interpreting Excellon Drill Files - Charlie - Up to 8
\end_layout

\begin_layout Standard
The Excellon file format is used to drive CNC milling / drilling machines.
 These files contain information regarding drill specifications and drill
 co-ordinates using the extension '.drl'.
 When a PCB design program produces a template to be chemically etcshed,
 it also creates one of these files to map where holes need to be drilled.
 We receive one of these files over an RS232 link and one of our tasks is
 to write a program which can interpret it.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:excellon-sample"

\end_inset

 shows a typical example of an Excellon drill file.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
M48
\end_layout

\begin_layout LyX-Code
;DRILL file {Pcbnew (2011-dec-21)-stable} date Sun 19 Feb 2012 02:32:52
 GMT
\end_layout

\begin_layout LyX-Code
;FORMAT={-:-/ absolute / inch / decimal}
\end_layout

\begin_layout LyX-Code
FMAT,2
\end_layout

\begin_layout LyX-Code
INCH,TZ
\end_layout

\begin_layout LyX-Code
T1C0.032
\end_layout

\begin_layout LyX-Code
T2C0.045
\end_layout

\begin_layout LyX-Code
T3C0.120
\end_layout

\begin_layout LyX-Code
%
\end_layout

\begin_layout LyX-Code
G90
\end_layout

\begin_layout LyX-Code
G05
\end_layout

\begin_layout LyX-Code
M72
\end_layout

\begin_layout LyX-Code
T1
\end_layout

\begin_layout LyX-Code
X3.350Y4.475
\end_layout

\begin_layout LyX-Code
X3.350Y4.575
\end_layout

\begin_layout LyX-Code
X3.450Y4.475
\end_layout

\begin_layout LyX-Code
X4.872Y3.586
\end_layout

\begin_layout LyX-Code
X5.200Y2.900
\end_layout

\begin_layout LyX-Code
X5.272Y3.986
\end_layout

\begin_layout LyX-Code
X5.272Y4.164
\end_layout

\begin_layout LyX-Code
X5.300Y2.800
\end_layout

\begin_layout LyX-Code
X5.900Y3.900
\end_layout

\begin_layout LyX-Code
X6.200Y3.400
\end_layout

\begin_layout LyX-Code
X6.200Y3.500
\end_layout

\begin_layout LyX-Code
X6.200Y3.600
\end_layout

\begin_layout LyX-Code
T2
\end_layout

\begin_layout LyX-Code
X5.350Y3.150
\end_layout

\begin_layout LyX-Code
X5.850Y2.700
\end_layout

\begin_layout LyX-Code
X6.050Y2.875
\end_layout

\begin_layout LyX-Code
X6.250Y2.700
\end_layout

\begin_layout LyX-Code
X6.450Y2.875
\end_layout

\begin_layout LyX-Code
X6.750Y3.270
\end_layout

\begin_layout LyX-Code
X6.750Y3.380
\end_layout

\begin_layout LyX-Code
X6.750Y3.485
\end_layout

\begin_layout LyX-Code
T3
\end_layout

\begin_layout LyX-Code
X3.275Y3.150
\end_layout

\begin_layout LyX-Code
X3.275Y4.150
\end_layout

\begin_layout LyX-Code
X3.950Y3.250
\end_layout

\begin_layout LyX-Code
X6.800Y3.000
\end_layout

\begin_layout LyX-Code
X6.800Y4.300
\end_layout

\begin_layout LyX-Code
T0
\end_layout

\begin_layout LyX-Code
M30
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An Excellon drill file
\begin_inset CommandInset label
LatexCommand label
name "fig:excellon-sample"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This file can be broken down into two separate sections: the header and
 the co-ordinate list.
\end_layout

\begin_layout Subsubsection
The Header
\end_layout

\begin_layout Standard
This contains information regarding the set-up of the machine and the format
 of the co-ordinate list:
\end_layout

\begin_layout LyX-Code
M48
\end_layout

\begin_layout Standard
This indicates that the file has begun.
\end_layout

\begin_layout LyX-Code
;DRILL file {Pcbnew (2011-dec-21)-stable} date Sun 19 Feb 2012 02:32:52
 GMT
\end_layout

\begin_layout LyX-Code
;FORMAT={-:-/ absolute / inch / decimal} FMAT,2 INCH,TZ T1C0.032 T2C0.045
 T3C0.120 % G90 G05
\end_layout

\begin_layout Standard
Lines that begin with a semicolon are comments and can be ignored.
\end_layout

\begin_layout LyX-Code
FMAT,2
\end_layout

\begin_layout Standard
The code is in the newer 2nd format.
\end_layout

\begin_layout LyX-Code
INCH, TZ
\end_layout

\begin_layout Standard
The co-ordinates are in inches and trailing zeros have been added where
 nessecary
\end_layout

\begin_layout LyX-Code
TaCb
\end_layout

\begin_layout Standard
Tool (drill-bit) 'a' has a diameter of 'b'
\end_layout

\begin_layout LyX-Code
%
\end_layout

\begin_layout Standard
Beginning of new pattern (note: Excellon files are often viewed as a series
 of patterns rather than a header and co-ordinate list.
 However, for our purposes patterns are irrelevant and we can ignore the
 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 symbol entirely)
\end_layout

\begin_layout LyX-Code
G90
\end_layout

\begin_layout Standard
The co-ordinates are absolute (as opposed to relative - G91, where the previous
 co-ordinate is always treated as 0,0)
\end_layout

\begin_layout LyX-Code
G05
\end_layout

\begin_layout Standard
Drill mode (as opposed to routing mode – G00)
\end_layout

\begin_layout Standard
There are many other possible header commands which for our purposes we
 do not need to consider.
 For a comprehensive list see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://web.archive.org/web/20071030075236/http://www.excellon.com/manuals/program.htm
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
The Co-ordinate List
\end_layout

\begin_layout LyX-Code
Tn
\end_layout

\begin_layout Standard
Insert tool 'n'
\end_layout

\begin_layout LyX-Code
XaYb
\end_layout

\begin_layout Standard
X co-ordinate = a, Y co-ordinate = b
\end_layout

\begin_layout LyX-Code
T0
\end_layout

\begin_layout Standard
Unload current tool
\end_layout

\begin_layout LyX-Code
M30
\end_layout

\begin_layout Standard
End program
\end_layout

\begin_layout Subsubsection
A Simplified Solution
\end_layout

\begin_layout Standard
See figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Interpreter-flowchart"

\end_inset

 for a flowchart of a simpler version of this program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Drill File Interpreter Flowchart.jpg
	width 18cm
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A flowchart demonstrating a simple version of the Excellon interpreter
\begin_inset CommandInset label
LatexCommand label
name "fig:Interpreter-flowchart"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This program is an Event Based Parser.
 It reads the Excellon file 1 character at a time.
\end_layout

\begin_layout Standard
This simplified version is only designed to handle lines of co-ordinates.
\end_layout

\begin_layout Standard
The program begins when it receives an interrupt which is triggered when
 a character is sent.
 The “rs232-activity” variable is handled by a separate program.
 It indicates that there is data being sent along the rs232 cable and so
 it is initially set high.
\end_layout

\begin_layout Standard
The program next looks to see if the sent character is a number.
 If not, it checks if it is an 'X', a 'Y' or a '
\backslash
n'.
\end_layout

\begin_layout Standard
If the character is an 'X' or a 'Y' the variable “state” is changed to the
 corresponding letter.
\end_layout

\begin_layout Standard
If it is a '
\backslash
n' then the current set of co-ordinates stored in “X_target” and “Y_target”
 are handled by a sub-process which passes them on to a separate program.
 “state” is then set to empty or “-”, and “X_target” and “Y_target” are
 reset.
 This is done as “
\backslash
n” indicates that the current set of co-ordinates has been sent and the
 next set is about to be recieved.
\end_layout

\begin_layout Standard
If a letter is passed which is not one of the above the program assumes
 there has been a malfunction somewhere, so “error” is set to 1 and “state”,
 “X_target” and “Y_target” are all reset.
\end_layout

\begin_layout Standard
If a number has been sent then the program checks the value of “state”.
 If the state is 'X' or 'Y' then the number will be stored in “X_target”
 or “Y_target” respectively.
 However, if “state” is '-' , something has gone wrong, so the number is
 not stored, “error” is set to 1 and “state”, “X_target” and “Y_target”
 are all again reset.
\end_layout

\begin_layout Standard
When a number is stored in “X_target” or “Y_target” it would be incorrect
 to overwrite the current value, as the co-ordinates are being sent one
 digit at a time and each co-ordinate has multiple digits.
 The program should add each subsequent digit on to the end of the current
 value, so the + operator will not work either.
\end_layout

\begin_layout Standard
To demonstrate this, consider the number 42 being sent to the program.
\end_layout

\begin_layout Standard
Initially the first number, 4, is stored in the relevant target variable.
\end_layout

\begin_layout Standard
If the following 2 is simply stored in the variable it will equal 2, rather
 that 42.
\end_layout

\begin_layout Standard
If the variable is + the 2 it will equal 6, which is also incorrect.
\end_layout

\begin_layout Standard
The solution is to multiply the target variable by 10 and then add the next
 character.
 This way when the 2 is sent the 4 is changed to 40.
 The 2 is then added, giving 42 as required.
\end_layout

\begin_layout Standard
However, this simple program does not take into account the specifics of
 the Excellon format.
 A programmable solution was needed which took these nuances into account.
\end_layout

\begin_layout Subsubsection
The Final Solution
\end_layout

\begin_layout Standard
This final program was named 
\begin_inset Quotes eld
\end_inset

serial.c
\begin_inset Quotes erd
\end_inset

.
 Much like the simplified model, serial.c begins by setting rs232_activity_count
 to 5.
 It then checks the first letter of the line to see what kind of information
 is about to be sent.
 A 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

 is then set corresponding to the letter and the rest of the line is processed
 accordingly.
 This is done by checking if the sent character is a letter whenever the
 state = STATE_NONE.
 It then sets state to the recieved letter.
 Whenever a new line character (
\backslash
n) is recieved state is reset to STATE_NONE, and so the first letter of
 each line ultimately determines the way it is interpreted.
\end_layout

\begin_layout LyX-Code
/* A character is sent */
\end_layout

\begin_layout LyX-Code
static void receive ( char data ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* Set the RS232 activity counter */
\end_layout

\begin_layout LyX-Code
rs232_activity_count = 5;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/* If there is an error end process */ 	
\end_layout

\begin_layout LyX-Code
if ( error != 0 ) 		
\end_layout

\begin_deeper
\begin_layout LyX-Code
return;
\end_layout

\end_deeper
\begin_layout LyX-Code
/* Check to see if a state has been set */
\end_layout

\begin_layout LyX-Code
else if ( state == STATE_NONE ) { 	
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* If data is an G, set state to G */ 
\end_layout

\begin_layout LyX-Code
if ( data == 'G' ) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_G; 	
\end_layout

\end_deeper
\begin_layout LyX-Code
} 	
\end_layout

\begin_layout LyX-Code
/* If data is an M, set state to M */ 
\end_layout

\begin_layout LyX-Code
else if ( data == 'M' ) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_M; 	
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
/* If data is an T, set state to T */
\end_layout

\begin_layout LyX-Code
else if ( data == 'T' ) { 		
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_T; 	
\end_layout

\end_deeper
\begin_layout LyX-Code
} 	
\end_layout

\begin_layout LyX-Code
/* If data is an X, set state to X */ 
\end_layout

\begin_layout LyX-Code
else if ( data == 'X' ) { 		
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_X; 	
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
/* If data is an Y, set state to Y */ 
\end_layout

\begin_layout LyX-Code
else if ( data == 'Y' ) { 			
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_Y; 		
\end_layout

\end_deeper
\begin_layout LyX-Code
} else {
\end_layout

\begin_layout LyX-Code
/* Otherwise the line may be ignored */		
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_IGNORE; 	
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
When the program recieves a character and a state is set, the character
 is sent to one of several separate functions.
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
/* If the state is T, process data */
\end_layout

\begin_layout LyX-Code
else if ( state == STATE_T ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
handle_t ( data );
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout LyX-Code
/* If the state is X or Y, process data */
\end_layout

\begin_layout LyX-Code
else if ( ( state == STATE_X ) || ( state == STATE_Y ) ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
handle_x_and_y ( data );
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
/* If data is a new line reset */
\end_layout

\begin_layout LyX-Code
else if ( data == '
\backslash
r' ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
reset();
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The way these functions process characters varies slightly.
 For example, in STATE_T a typical line might look like
\end_layout

\begin_layout LyX-Code
T2C0.045
\end_layout

\begin_layout Standard
The function handle_t() is called for this line.
 The 'T' has already been dealt with, so the first character sent to the
 function is the two.
 The program's first check differentiates between characters and numbers.
 All numbers are initially converted from ASCII characters to number values
 so that they can be usefully handled.
 These numbers are then stored in a variable named 
\begin_inset Quotes eld
\end_inset

T_value
\begin_inset Quotes erd
\end_inset

 using the * 10, + value principle explained in the simplified solution.
 As T_value is supposed to store the number of the specified drillbit the
 program will set an error if it gets too large.
 For testing purposes the program has also been designed to print the inputted
 value of T_value when it is set, as well as a specific error message when
 an error is set.
 The numbers after the letter 'C' in the example line specify the diameter
 of drillbit 2.
 When the program recieves this letter it treats it as a letter rather than
 a number and instead sets the state to STATE_C.
 This way when the following numbers are inputted they will be handled by
 a separate function called handle_c() which assigns the current value of
 T_value a specific drillbit dimension .
 If a letter other than 'C' is sent to the function, there has clearly been
 an mistake somewhere so an error is set and an error message is printed.
\end_layout

\begin_layout LyX-Code
/* Handles data in state T */
\end_layout

\begin_layout LyX-Code
static void handle_t ( char data ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* If data is a co-ordinate number, store it */
\end_layout

\begin_layout LyX-Code
if ( ( data >= '0' ) && ( data <= '9' ) ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* Convert the character (data), into a number (value) */
\end_layout

\begin_layout LyX-Code
value = data - '0'; 	
\end_layout

\begin_layout LyX-Code
/* Add data to T_value */
\end_layout

\begin_layout LyX-Code
printf ( "T: %d
\backslash
n", T_value );
\end_layout

\begin_layout LyX-Code
T_value *= 10;
\end_layout

\begin_layout LyX-Code
T_value += value;
\end_layout

\begin_layout LyX-Code
/* If T_value is too large set error */
\end_layout

\begin_layout LyX-Code
if ( T_value > MAX_DRILL_BITS ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf( "
\backslash
nError: State T, T_value is too large" );
\end_layout

\begin_layout LyX-Code
error = 1;
\end_layout

\begin_layout LyX-Code
reset();
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout LyX-Code
/* If data is a C, set state to C */
\end_layout

\begin_layout LyX-Code
else if ( data == 'C' ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_C;
\end_layout

\end_deeper
\begin_layout LyX-Code
} else {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* If data is unusable, set error */
\end_layout

\begin_layout LyX-Code
printf( "
\backslash
nError: State T, invalid character" );
\end_layout

\begin_layout LyX-Code
error = 1;
\end_layout

\begin_layout LyX-Code
reset();
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
There are similar functions for STATE_G and STATE_M.
 When a co-ordinate line begins a slightly more complicated method of interpreta
tion is needed, as there may be no change in the X or Y co-ordinate and
 therefore the line would be half as long.
 Here is a typical example of a co-ordinate line
\end_layout

\begin_layout LyX-Code
X4.872Y3.586
\end_layout

\begin_layout Standard
The function handle_x_and_y() is called if the state is STATE_X or STATE_Y.
 Again, if a number is sent it will be converted into a usable form and
 stored in a variable.
 In STATE_X the number is stored in new_target_x and in STATE_Y the number
 is stored in new_target_y.
 Just like the letter 'C' in the previous example, if a 'Y' is sent to the
 function the state will change to STATE_Y.
 If a character other than a number or a 'Y' is sent, an error will again
 be set with an accompanying error message.
 The program makes an exception for the '.' character which is ignored.
\end_layout

\begin_layout Standard
When the '
\backslash
n' character is sent to the function the co-ordinates are stored.
 In the normal 
\begin_inset Quotes eld
\end_inset

absolute co-ordinates
\begin_inset Quotes erd
\end_inset

 mode the program simply stores new_target_x and new_target_y in the variables
 X_target and Y_target.
 However, if the header has specified 
\begin_inset Quotes eld
\end_inset

relative co-ordinates
\begin_inset Quotes erd
\end_inset

 mode the variable 
\begin_inset Quotes eld
\end_inset

relative-coordinates
\begin_inset Quotes erd
\end_inset

 will be high and the program will detect this.
 Instead, new_target_x and new_target_y will be added to X_target and Y_target.
 Once this has taken place the co-ordinates are stored in 
\begin_inset Quotes eld
\end_inset

targets [ target_prod ].x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

targets [ target_prod ].y
\begin_inset Quotes erd
\end_inset

, which are defined externally and can be accessed by other programs.
 Every time a '
\backslash
n' character is sent, target_prod is increased by one and reset() is called.
 reset() makes new_Y_target, new_X_target, G_value, M_value and T_value
 all equal zero and it is called at the end of every function when a '
\backslash
n' character is recieved.
\end_layout

\begin_layout LyX-Code
/* Handles data in state X and Y */
\end_layout

\begin_layout LyX-Code
static void handle_x_and_y ( char data ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* If data is a co-ordinate number, store it */
\end_layout

\begin_layout LyX-Code
if ( ( data >= '0' ) && ( data <= '9' ) ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* Convert the character (data), into a number (value) */
\end_layout

\begin_layout LyX-Code
value = data - '0';
\end_layout

\begin_layout LyX-Code
/* If state is X, add data to X_target */
\end_layout

\begin_layout LyX-Code
if ( state == STATE_X ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
new_X_target *= 10;
\end_layout

\begin_layout LyX-Code
new_X_target += value;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 	
\end_layout

\begin_layout LyX-Code
/* If state is Y, add data to Y_target */
\end_layout

\begin_layout LyX-Code
else if ( state == STATE_Y ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
new_Y_target *= 10;
\end_layout

\begin_layout LyX-Code
new_Y_target += value;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
else if ( data == '.' ) {
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout LyX-Code
/* If data is Y, set state to Y */
\end_layout

\begin_layout LyX-Code
else if ( data == 'Y' ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
state = STATE_Y;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
/* If data is a new line operator, store co-ordinates and reset */
\end_layout

\begin_layout LyX-Code
else if ( data == '
\backslash
r' ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* Store co-ordinates in relative or absolute mode */
\end_layout

\begin_layout LyX-Code
if ( relative_coordinates == 1 ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
X_target += new_X_target;
\end_layout

\begin_layout LyX-Code
Y_target += new_Y_target;
\end_layout

\begin_layout LyX-Code
} else {
\end_layout

\begin_layout LyX-Code
X_target = new_X_target;
\end_layout

\begin_layout LyX-Code
Y_target = new_Y_target;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
targets [ target_prod ].x = X_target;
\end_layout

\begin_layout LyX-Code
targets [ target_prod ].y = Y_target;
\end_layout

\begin_layout LyX-Code
printf( "X: %d", new_X_target );
\end_layout

\begin_layout LyX-Code
printf( ", Y: %d
\backslash
n", new_Y_target );
\end_layout

\begin_layout LyX-Code
target_prod += 1;
\end_layout

\begin_layout LyX-Code
reset ();
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
/* If data is unusable, set error */
\end_layout

\begin_layout LyX-Code
else {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf( "
\backslash
nError: State X or Y, invalid character" );
\end_layout

\begin_layout LyX-Code
error = 1;
\end_layout

\begin_layout LyX-Code
reset();
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
All of these functions act in much the same way and together they make up
 the main part of 
\begin_inset Quotes eld
\end_inset

serial.c
\begin_inset Quotes erd
\end_inset

 which can now succesfully interpret an Excellon drill file.
 See the appendix for the full code
\end_layout

\begin_layout Subsection
Buttons - Abi - 3
\end_layout

\begin_layout Section
Evaluation and Summary - Abi -1
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Subsection
Callibrations and Matrices - Pippa - 4
\end_layout

\begin_layout Subsubsection
Matrix multiplication
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left(\begin{array}{cc}
a & b\\
c & d\end{array}\right)\left(\begin{array}{c}
x\\
y\end{array}\right)=\left(\begin{array}{c}
ax+by\\
cx+dy\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Matrices are used to transform coordinates and vectors.
\end_layout

\begin_layout Standard
They can be applied to shapes using the same method as shown in the following
 examples.
\end_layout

\begin_layout Standard
The following matrices will be applied to shape N:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather}
\left(\begin{array}{cc}
1 & 0\\
0 & 1\end{array}\right)\label{eq:identity_matrix}\\
\left(\begin{array}{cc}
2 & 0\\
0 & 2\end{array}\right)\label{eq:scale_two}\\
\left(\begin{array}{cc}
0 & -1\\
1 & 0\end{array}\right)\label{eq:rotate_90}\end{gather}

\end_inset


\end_layout

\begin_layout Paragraph
Matrix 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity_matrix"

\end_inset


\end_layout

\begin_layout Standard
Also known as the IDENTITY matrix, scaling by a factor of one.
\end_layout

\begin_layout Standard
e.g.
\begin_inset Formula \[
\left(\begin{array}{cc}
1 & 0\\
0 & 1\end{array}\right)\left(\begin{array}{c}
1\\
3\end{array}\right)=\left(\begin{array}{c}
1\\
3\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Paragraph
Matrix 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:scale_two"

\end_inset


\end_layout

\begin_layout Standard
Scaling by a factor of two.
\end_layout

\begin_layout Standard
e.g.
\begin_inset Formula \[
\left(\begin{array}{cc}
2 & 0\\
0 & 2\end{array}\right)\left(\begin{array}{c}
1\\
3\end{array}\right)=\left(\begin{array}{c}
2\\
6\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Paragraph
Matrix 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rotate_90"

\end_inset


\end_layout

\begin_layout Standard
Rotation left by 90°.
\end_layout

\begin_layout Standard
e.g.
\begin_inset Formula \[
\left(\begin{array}{cc}
0 & -1\\
1 & 0\end{array}\right)\left(\begin{array}{c}
1\\
3\end{array}\right)=\left(\begin{array}{c}
-3\\
1\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Subsubsection
Origin
\end_layout

\begin_layout Standard
All three of these matrix transformations take place around the origin since
 it is unaffected by matrices; any matrix applied to the origin will return
 the origin as a result:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left(\begin{array}{cc}
a & b\\
c & d\end{array}\right)\left(\begin{array}{c}
0\\
0\end{array}\right)=\left(\begin{array}{c}
0\\
0\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Subsubsection
Rotation
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Rotation left by an angle 
\begin_inset Formula $\theta$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Rotation-left"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen from figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rotation-left"

\end_inset

, the coordinates of the point P relative to the rotated reference frame
 are:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\hat{x} & = & x\cos\theta-y\sin\theta\\
\hat{y} & = & x\sin\theta+y\cos\theta\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This can be expressed as a matrix multiplication:
\begin_inset Formula \[
\left(\begin{array}{c}
\hat{x}\\
\hat{y}\end{array}\right)=\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta\end{array}\right)\left(\begin{array}{c}
x\\
y\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Standard
The transformation matrix for a rotation of an angle 
\begin_inset Formula $\theta$
\end_inset

 is therefore
\begin_inset Formula \[
\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta\end{array}\right)\]

\end_inset


\end_layout

\begin_layout Section
Acknowledgements - Pippa - 1
\end_layout

\begin_layout Section
Appendices
\end_layout

\begin_layout Subsection
Code Listings
\end_layout

\begin_layout Subsubsection
Manual input of co-ordinates (Cambridge Workshop Program)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/charlie/xyzebra/src/dlpusb245_control.c"

\end_inset


\end_layout

\begin_layout Subsubsection
Interpreting Excellon drill filles
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/charlie/xyzebra/src/rs232/serial.c"

\end_inset


\end_layout

\begin_layout Subsection
Schematics
\end_layout

\begin_layout Subsection
PCB Layouts
\end_layout

\end_body
\end_document
